"""
Code generator for the generalized block syntax.

The generator simply serializes the parsed AST and feeds it into the block
runtime helper. Pygame blocks (with _pygame_code) are generated as raw Python.
"""

from __future__ import annotations

from textwrap import dedent, indent
from typing import Any, Dict, Optional


class BlockCodeGenerator:
    """Emit Python code for the block-based LevLang syntax."""

    def __init__(self, ast: Optional[Dict[str, Any]]):
        self.ast = ast or {}

    def generate(self) -> str:
        # Separate pygame blocks from regular blocks
        blocks = self.ast.get("blocks", {})
        pygame_blocks = {}
        regular_blocks = {}
        
        for name, content in blocks.items():
            if isinstance(content, dict) and "_pygame_code" in content:
                pygame_blocks[name] = content["_pygame_code"]
            else:
                regular_blocks[name] = content
        
        # Generate pygame code blocks as functions
        # Track which blocks actually have code (to avoid calling empty ones)
        pygame_functions = []
        non_empty_pygame_blocks = []
        
        for block_name, code_lines in pygame_blocks.items():
            # Remove common leading whitespace
            if code_lines:
                min_indent = float('inf')
                for line in code_lines:
                    if line.strip():  # Skip empty lines
                        leading_spaces = len(line) - len(line.lstrip())
                        min_indent = min(min_indent, leading_spaces)
                
                if min_indent == float('inf'):
                    min_indent = 0
                
                # Remove the common indentation
                dedented_lines = [line[min_indent:] if len(line) > min_indent else line.lstrip() 
                                  for line in code_lines]
                
                func_code = "\n".join(dedented_lines)
                # Pygame blocks receive screen and clock as parameters
                pygame_functions.append(
                    f"def {block_name}(screen, clock, entities=None):\n"
                    f"    \"\"\"Custom pygame code block.\"\"\"\n"
                    f"{indent(func_code, '    ')}\n"
                )
                # Only track blocks that actually have code
                non_empty_pygame_blocks.append(block_name)
        
        pygame_code_section = "\n".join(pygame_functions) if pygame_functions else ""
        
        globals_data = repr(self.ast.get("globals", {}))
        ui_data = repr(self.ast.get("ui", []))

        if regular_blocks or not pygame_blocks:
            # Generate standard block-based game
            blocks_repr = repr(regular_blocks)
            
            # Build script without using f-string inside dedent for pygame_code_section
            base_script = """# Generated by LevLang BlockCodeGenerator
# NOTE: Edits to this file will be overwritten on the next build.

from levlang.runtime.simple_runtime import run_block_game

"""
            if pygame_code_section:
                base_script += pygame_code_section + "\n"
            
            base_script += f"""BLOCK_DATA = {{
    "blocks": {blocks_repr},
    "globals": {globals_data},
    "ui": {ui_data},
    "pygame_blocks": {non_empty_pygame_blocks!r},
}}


def main():
    run_block_game(BLOCK_DATA)


if __name__ == "__main__":
    main()
"""
            script = base_script
        else:
            # Pure pygame mode - create a proper pygame window and call blocks
            base_script = """# Generated by LevLang BlockCodeGenerator
# NOTE: Edits to this file will be overwritten on the next build.

import pygame
import sys

"""
            if pygame_code_section:
                base_script += pygame_code_section + "\n"
            
            base_script += """if __name__ == "__main__":
    pygame.init()
    screen = pygame.display.set_mode((800, 600))
    pygame.display.set_caption("LevLang Pygame")
    clock = pygame.time.Clock()
    running = True
    
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False
        
        screen.fill((0, 0, 0))
        
        # Call all pygame blocks with screen and clock
"""
            # Only call blocks that actually have function definitions
            for name in non_empty_pygame_blocks:
                base_script += f"        {name}(screen, clock)\n"
            
            base_script += """        
        pygame.display.flip()
        clock.tick(60)
    
    pygame.quit()
    sys.exit()
"""
            
            script = base_script

        return script + "\n"

