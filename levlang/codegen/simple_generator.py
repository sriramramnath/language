"""
Code generator for LevLang v3 - A component-based language.
"""
import re
from typing import Dict, Any

class SimpleCodeGenerator:
    """
    Generates Python/pygame code from a component-based AST.
    This version is generic and not hard-coded for a specific game.
    """
    
    def __init__(self, ast: Dict[str, Any]):
        self.ast = ast
        self.code_lines = []

    def generate(self) -> str:
        """Generate complete Python code."""
        self._emit_header()
        self._emit_constants()
        self._emit_game_functions()
        self._emit_component_classes()
        self._emit_main_function()
        return '\n'.join(self.code_lines)

    def _emit(self, line: str = '', indent: int = 0):
        self.code_lines.append(' ' * (4 * indent) + line)

    def _emit_header(self):
        self._emit("# Generated by LevLang v3 Transpiler")
        self._emit("import pygame, sys, random, os, re")
        self._emit("pygame.init()")
        self._emit()

    def _emit_constants(self):
        self._emit("# --- Constants ---")
        self._emit("WIDTH, HEIGHT = 800, 600")
        self._emit("BLACK = (0, 0, 0)")
        self._emit("WHITE = (255, 255, 255)")
        self._emit("RED = (255, 0, 0)")
        self._emit("GREEN = (0, 255, 0)")
        self._emit("BLUE = (0, 0, 255)")
        self._emit("CYAN = (0, 200, 200)")
        self._emit("FPS = 60")
        self._emit()
        self._emit("screen = pygame.display.set_mode((WIDTH, HEIGHT))")
        self._emit("pygame.display.set_caption('LevLang Game')")
        self._emit("clock = pygame.time.Clock()")
        self._emit()

    def _emit_game_functions(self):
        self._emit("# --- Helper Functions ---")
        self._emit("def draw_text(surface, text, size, x, y, color=WHITE):")
        self._emit("    font = pygame.font.Font(None, size)", 1)
        self._emit("    text_surface = font.render(str(text), True, color)", 1)
        self._emit("    text_rect = text_surface.get_rect(center=(x, y))", 1)
        self._emit("    surface.blit(text_surface, text_rect)", 1)
        self._emit()

    def _emit_component_classes(self):
        self._emit("# --- Component Classes ---")
        self._emit("class BaseEntity:")
        self._emit("    def __init__(self):", 1)
        self._emit("        self.rect = pygame.Rect(0, 0, 0, 0)", 2)
        self._emit("        self.speed = 0", 2)
        self._emit("        self.score = 0", 2)
        self._emit("        self.active = True", 2)
        self._emit("    def update(self, keys, entities):", 1)
        self._emit("        pass", 2)
        self._emit("    def draw(self, surface):", 1)
        self._emit("        pygame.draw.rect(surface, WHITE, self.rect)", 2)
        self._emit()

        components = self.ast.get('components', {})
        for name, props in components.items():
            class_name = name.capitalize()
            self._emit(f"class {class_name}(BaseEntity):")
            self._emit("def __init__(self, overrides):", 1)
            self._emit("super().__init__()", 2)
            
            for key, value in props.items():
                self._emit(f"self.{key} = {repr(value)}", 2)
            self._emit("for key, value in overrides.items(): setattr(self, key, value)", 2)

            size = props.get('size', '32x32')
            try:
                parts = size.split('x')
                if len(parts) != 2:
                    raise ValueError(f"Size must be in format 'WIDTHxHEIGHT', got: {size}")
                width, height = int(parts[0]), int(parts[1])
            except (ValueError, AttributeError) as e:
                raise ValueError(f"Invalid size format '{size}': {e}")
            self._emit(f"self.rect = pygame.Rect(0, 0, {width}, {height})", 2)
            
            if props.get('behavior') and 'bounce' in props.get('behavior'):
                self._emit("self.speed_x = self.speed * random.choice((1, -1))", 2)
                self._emit("self.speed_y = self.speed * random.choice((1, -1))", 2)
            self._emit()

            # --- DYNAMIC UPDATE METHOD ---
            self._emit("def update(self, keys, entities):", 1)
            # --- Controls Logic ---
            self._emit("if hasattr(self, 'controls'):", 2)
            self._emit("    if self.controls == 'vertical(\"w\", \"s\")':", 3)
            self._emit("        if keys[pygame.K_w]: self.rect.y -= self.speed", 4)
            self._emit("        if keys[pygame.K_s]: self.rect.y += self.speed", 4)
            self._emit("    elif self.controls == 'horizontal':", 3)
            self._emit("        if keys[pygame.K_a] or keys[pygame.K_LEFT]: self.rect.x -= self.speed", 4)
            self._emit("        if keys[pygame.K_d] or keys[pygame.K_RIGHT]: self.rect.x += self.speed", 4)
            self._emit("    elif self.controls.startswith('ai_track'):", 3)
            self._emit("        target_name = self.controls.split('\"')[1]", 4)
            self._emit("        target = entities.get(target_name)", 4)
            self._emit("        if target:", 4)
            self._emit("            if self.rect.centery < target.rect.centery: self.rect.y += self.speed", 5)
            self._emit("            if self.rect.centery > target.rect.centery: self.rect.y -= self.speed", 5)
            
            # --- Behavior Logic ---
            self._emit("if hasattr(self, 'behavior'):", 2)
            self._emit("    if 'move_down' in self.behavior:", 3)
            self._emit("        self.rect.y += self.speed", 4)
            self._emit("    if 'bounce' in self.behavior:", 3)
            self._emit("        self.rect.x += self.speed_x", 4)
            self._emit("        self.rect.y += self.speed_y", 4)
            self._emit("        if self.rect.top <= 0 or self.rect.bottom >= HEIGHT: self.speed_y *= -1", 4)
            self._emit("        match = re.search(r'bounce_on\\(\"([^\\\"]+)\")\\)', self.behavior)", 4)
            self._emit("        if match:", 4)
            self._emit("            comp_name = match.group(1)", 5)
            self._emit("            for entity in entities.values():", 5)
            self._emit("                if entity.__class__.__name__.lower() == comp_name and self.rect.colliderect(entity.rect):", 6)
            self._emit("                    self.speed_x *= -1", 7)

            # --- Keep on screen ---
            self._emit("if self.rect.top < 0: self.rect.top = 0", 2)
            self._emit("if self.rect.bottom > HEIGHT: self.rect.bottom = HEIGHT", 2)
            self._emit("if self.rect.left < 0: self.rect.left = 0", 2)
            self._emit("if self.rect.right > WIDTH: self.rect.right = WIDTH", 2)
            self._emit()

            # --- DRAW METHOD ---
            self._emit("def draw(self, surface):", 1)
            color = props.get('color', 'WHITE').upper()
            if props.get('shape') == 'rectangle':
                self._emit(f"pygame.draw.rect(surface, {color}, self.rect)", 2)
            elif props.get('shape') == 'circle':
                self._emit(f"pygame.draw.ellipse(surface, {color}, self.rect)", 2)
            self._emit()

    def _emit_main_function(self):
        self._emit("# --- Main Game ---")
        self._emit("def main():")
        self._emit("entities = {}", 1)
        for name, config in self.ast.get('entities', {}).items():
            class_name = config['component'].capitalize()
            overrides = config.get('overrides', {})
            self._emit(f"entities['{name}'] = {class_name}({overrides})", 1)
            self._parse_position(name, overrides.get('position', 'center'))
        self._emit()

        self._emit("running = True", 1)
        self._emit("while running:", 1)
        self._emit("clock.tick(FPS)", 2)
        self._emit("keys = pygame.key.get_pressed()", 2)
        self._emit("for event in pygame.event.get():", 2)
        self._emit("if event.type == pygame.QUIT or keys[pygame.K_ESCAPE]: running = False", 3)
        self._emit()
        
        self._emit("for entity in entities.values(): entity.update(keys, entities)", 2)
        self._emit()

        # Generic Event/Rule processing
        game_rules = self.ast.get('game', {})
        for rule in game_rules.get('on_event', []):
            self._parse_rule(rule)
        self._emit()

        self._emit("screen.fill(BLACK)", 2)
        if game_rules.get('draw') == 'dashed_line(center)':
            self._emit("for i in range(10, HEIGHT, 25): pygame.draw.rect(screen, WHITE, (WIDTH // 2 - 2, i, 4, 10))", 2)
        self._emit("for entity in entities.values(): entity.draw(screen)", 2)
        
        for ui_rule in game_rules.get('ui', []):
            self._parse_ui(ui_rule)
        self._emit()

        self._emit("pygame.display.flip()", 2)
        self._emit()
        self._emit("pygame.quit()", 1)
        self._emit("sys.exit()", 1)
        self._emit()
        self._emit('if __name__ == "__main__": main()')

    def _parse_position(self, name, pos):
        if pos == 'center':
            self._emit(f"entities['{name}'].rect.center = (WIDTH // 2, HEIGHT // 2)", 1)
        elif pos == 'bottom_center':
            self._emit(f"entities['{name}'].rect.midbottom = (WIDTH // 2, HEIGHT - 20)", 1)
        elif pos.startswith('left'):
            match = re.search(r'\\((\\d+)\\)', pos)
            offset = match.group(1) if match else "0"
            self._emit(f"entities['{name}'].rect.left = {offset}", 1)
            self._emit(f"entities['{name}'].rect.centery = HEIGHT // 2", 1)
        elif pos.startswith('right'):
            match = re.search(r'\\((\\d+)\\)', pos)
            offset = match.group(1) if match else "0"
            self._emit(f"entities['{name}'].rect.right = WIDTH - {offset}", 1)
            self._emit(f"entities['{name}'].rect.centery = HEIGHT // 2", 1)

    def _parse_rule(self, rule):
        # Simplified rule parser
        if 'offscreen_left' in rule and 'score' in rule:
            self._emit("if entities['the_ball'].rect.left <= 0:", 2)
            self._emit("    entities['opponent_paddle'].score += 1", 3)
            self._emit("    entities['the_ball'].rect.center = (WIDTH // 2, HEIGHT // 2)", 3)
        elif 'offscreen_right' in rule and 'score' in rule:
            self._emit("if entities['the_ball'].rect.right >= WIDTH:", 2)
            self._emit("    entities['player_paddle'].score += 1", 3)
            self._emit("    entities['the_ball'].rect.center = (WIDTH // 2, HEIGHT // 2)", 3)

    def _parse_ui(self, ui_rule):
        # Simplified UI parser
        if 'player_paddle.score' in ui_rule:
            self._emit("draw_text(screen, entities['player_paddle'].score, 64, WIDTH // 4, 50)", 2)
        if 'opponent_paddle.score' in ui_rule:
            self._emit("draw_text(screen, entities['opponent_paddle'].score, 64, WIDTH * 3 // 4, 50)", 2)
