"""Code generator for simplified LevLang syntax."""

from typing import Dict, Any, List


class SimpleCodeGenerator:
    """Generate Python/pygame code from simplified LevLang AST."""
    
    def __init__(self, ast: Dict[str, Any]):
        self.ast = ast
        self.code_lines = []
    
    def generate(self) -> str:
        """Generate complete Python code."""
        self._emit_header()
        self._emit_constants()
        self._emit_player_class()
        self._emit_obstacle_class()
        self._emit_road_class()
        self._emit_collision_function()
        self._emit_text_function()
        self._emit_gameover_screen()
        self._emit_main_function()
        
        return '\n'.join(self.code_lines)
    
    def _emit(self, line: str = ''):
        """Add a line of code."""
        self.code_lines.append(line)
    
    def _emit_header(self):
        """Generate imports and initialization."""
        self._emit("# Generated by LevLang Transpiler")
        self._emit("# This file was automatically generated from LevLang source code")
        self._emit()
        self._emit("import pygame")
        self._emit("import random")
        self._emit("import sys")
        self._emit()
        self._emit("# Initialize Pygame")
        self._emit("pygame.init()")
        self._emit()
    
    def _emit_constants(self):
        """Generate constants."""
        self._emit("# Constants")
        self._emit("WIDTH, HEIGHT = 800, 600")
        self._emit("FPS = 60")
        self._emit("WHITE = (255, 255, 255)")
        self._emit("BLACK = (0, 0, 0)")
        self._emit("RED = (255, 0, 0)")
        self._emit("GREEN = (0, 255, 0)")
        self._emit("BLUE = (0, 100, 255)")
        self._emit("GRAY = (100, 100, 100)")
        self._emit("YELLOW = (255, 255, 0)")
        self._emit()
        
        title = self.ast['game'].get('title', 'Game')
        self._emit("# Create display")
        self._emit("screen = pygame.display.set_mode((WIDTH, HEIGHT))")
        self._emit(f'pygame.display.set_caption("{title}")')
        self._emit("clock = pygame.time.Clock()")
        self._emit()
    
    def _emit_player_class(self):
        """Generate Player class."""
        player = self.ast.get('player', {})
        speed = player.get('speed', 5)
        
        self._emit("class Player:")
        self._emit("    def __init__(self):")
        self._emit("        self.width = 50")
        self._emit("        self.height = 80")
        self._emit("        self.x = WIDTH // 2 - self.width // 2")
        self._emit("        self.y = HEIGHT - self.height - 20")
        self._emit(f"        self.speed = {speed}")
        self._emit("        self.score = 0")
        self._emit("        ")
        self._emit("    def move(self, keys):")
        
        # Support both WASD and arrows
        movement = player.get('movement', 'wasd_arrows')
        if 'wasd' in str(movement) or 'arrows' in str(movement):
            self._emit("        if (keys[pygame.K_LEFT] or keys[pygame.K_a]) and self.x > 150:")
            self._emit("            self.x -= self.speed")
            self._emit("        if (keys[pygame.K_RIGHT] or keys[pygame.K_d]) and self.x < WIDTH - 150 - self.width:")
            self._emit("            self.x += self.speed")
            self._emit("        if (keys[pygame.K_UP] or keys[pygame.K_w]) and self.y > 0:")
            self._emit("            self.y -= self.speed")
            self._emit("        if (keys[pygame.K_DOWN] or keys[pygame.K_s]) and self.y < HEIGHT - self.height:")
            self._emit("            self.y += self.speed")
        
        self._emit("    ")
        self._emit("    def draw(self, surface):")
        self._emit("        # Car body")
        self._emit("        pygame.draw.rect(surface, BLUE, (self.x, self.y, self.width, self.height))")
        self._emit("        # Car windows")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x + 5, self.y + 10, self.width - 10, 25))")
        self._emit("        # Car wheels")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x - 5, self.y + 15, 10, 15))")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x + self.width - 5, self.y + 15, 10, 15))")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x - 5, self.y + 50, 10, 15))")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x + self.width - 5, self.y + 50, 10, 15))")
        self._emit()
    
    def _emit_obstacle_class(self):
        """Generate ObstacleCar class."""
        enemy = self.ast.get('enemy', {})
        
        self._emit("class ObstacleCar:")
        self._emit("    def __init__(self):")
        self._emit("        self.width = 50")
        self._emit("        self.height = 80")
        
        # Random lane spawning
        spawn = enemy.get('spawn', 'random_lane')
        if 'random' in str(spawn):
            self._emit("        self.x = random.choice([200, 300, 400, 500])")
        
        self._emit("        self.y = -100")
        
        # Speed handling
        speed = enemy.get('speed', 'rand(3, 6)')
        if 'rand' in str(speed):
            match = str(speed).replace('rand(', '').replace(')', '').split(',')
            if len(match) == 2:
                min_speed = match[0].strip()
                max_speed = match[1].strip()
                self._emit(f"        self.speed = random.randint({min_speed}, {max_speed})")
        else:
            self._emit(f"        self.speed = {speed}")
        
        self._emit("        self.color = random.choice([RED, GREEN, YELLOW, (255, 165, 0)])")
        self._emit("        ")
        self._emit("    def move(self):")
        self._emit("        self.y += self.speed")
        self._emit("    ")
        self._emit("    def draw(self, surface):")
        self._emit("        # Car body")
        self._emit("        pygame.draw.rect(surface, self.color, (self.x, self.y, self.width, self.height))")
        self._emit("        # Car windows")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x + 5, self.y + 45, self.width - 10, 25))")
        self._emit("        # Car wheels")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x - 5, self.y + 15, 10, 15))")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x + self.width - 5, self.y + 15, 10, 15))")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x - 5, self.y + 50, 10, 15))")
        self._emit("        pygame.draw.rect(surface, BLACK, (self.x + self.width - 5, self.y + 50, 10, 15))")
        self._emit("    ")
        self._emit("    def is_off_screen(self):")
        self._emit("        return self.y > HEIGHT")
        self._emit()
    
    def _emit_road_class(self):
        """Generate Road class."""
        road = self.ast.get('road', {})
        
        self._emit("class Road:")
        self._emit("    def __init__(self):")
        self._emit("        self.y1 = 0")
        self._emit("        self.y2 = -HEIGHT")
        self._emit("        self.line_speed = 5")
        self._emit("        ")
        self._emit("    def draw(self, surface):")
        self._emit("        # Road background")
        self._emit("        pygame.draw.rect(surface, GRAY, (150, 0, WIDTH - 300, HEIGHT))")
        self._emit("        # Road edges")
        self._emit("        pygame.draw.rect(surface, WHITE, (150, 0, 10, HEIGHT))")
        self._emit("        pygame.draw.rect(surface, WHITE, (WIDTH - 160, 0, 10, HEIGHT))")
        self._emit("        ")
        
        lanes = road.get('lanes', 3)
        self._emit(f"        # Lane dividers ({lanes} lanes)")
        self._emit(f"        for i in range({lanes - 1}):")
        self._emit("            x = 250 + i * 100")
        self._emit("            # Moving dashed lines")
        self._emit("            for y in range(int(self.y1), HEIGHT, 40):")
        self._emit("                pygame.draw.rect(surface, WHITE, (x, y, 5, 20))")
        self._emit("    ")
        self._emit("    def update(self):")
        self._emit("        self.y1 += self.line_speed")
        self._emit("        if self.y1 >= 40:")
        self._emit("            self.y1 = 0")
        self._emit()
    
    def _emit_collision_function(self):
        """Generate collision detection function."""
        self._emit("def check_collision(player, obstacle):")
        self._emit("    px, py = player.x, player.y")
        self._emit("    ox, oy = obstacle.x, obstacle.y")
        self._emit("    ")
        self._emit("    if (px < ox + obstacle.width and")
        self._emit("        px + player.width > ox and")
        self._emit("        py < oy + obstacle.height and")
        self._emit("        py + player.height > oy):")
        self._emit("        return True")
        self._emit("    return False")
        self._emit()
    
    def _emit_text_function(self):
        """Generate text drawing function."""
        self._emit("def draw_text(surface, text, size, x, y, color=WHITE):")
        self._emit("    font = pygame.font.Font(None, size)")
        self._emit("    text_surface = font.render(text, True, color)")
        self._emit("    text_rect = text_surface.get_rect()")
        self._emit("    text_rect.midtop = (x, y)")
        self._emit("    surface.blit(text_surface, text_rect)")
        self._emit()
    
    def _emit_gameover_screen(self):
        """Generate game over screen function."""
        gameover_items = self.ast.get('gameover', [])
        
        self._emit("def game_over_screen(score):")
        self._emit("    screen.fill(BLACK)")
        
        y_pos = "HEIGHT // 4"
        for item in gameover_items:
            text = item['text'].replace('{score}', '" + str(score) + "')
            
            if 'GAME OVER' in text:
                self._emit(f'    draw_text(screen, "{text}", 64, WIDTH // 2, {y_pos}, RED)')
                y_pos = "HEIGHT // 2"
            elif 'Score' in text:
                self._emit(f'    draw_text(screen, "Final Score: " + str(score), 40, WIDTH // 2, {y_pos})')
                y_pos = "HEIGHT * 3 // 4"
            elif 'SPACE' in text or 'Play' in text:
                self._emit(f'    draw_text(screen, "Press SPACE to Play Again", 30, WIDTH // 2, {y_pos})')
                y_pos = "HEIGHT * 3 // 4 + 40"
            elif 'ESC' in text or 'Quit' in text:
                self._emit(f'    draw_text(screen, "Press ESC to Quit", 30, WIDTH // 2, {y_pos})')
        
        self._emit("    pygame.display.flip()")
        self._emit("    ")
        self._emit("    waiting = True")
        self._emit("    while waiting:")
        self._emit("        for event in pygame.event.get():")
        self._emit("            if event.type == pygame.QUIT:")
        self._emit("                return False")
        self._emit("            if event.type == pygame.KEYDOWN:")
        self._emit("                if event.key == pygame.K_SPACE:")
        self._emit("                    return True")
        self._emit("                if event.key == pygame.K_ESCAPE:")
        self._emit("                    return False")
        self._emit("    return False")
        self._emit()
    
    def _emit_main_function(self):
        """Generate main game loop."""
        spawn_rate = self.ast.get('spawn_rate', 2)
        if isinstance(spawn_rate, str):
            spawn_rate = 2
        
        # Convert seconds to frames
        spawn_frames = spawn_rate * 60 if spawn_rate else 120
        difficulty = spawn_frames
        
        ui_items = self.ast.get('ui', [])
        
        self._emit("def main():")
        self._emit("    running = True")
        self._emit("    ")
        self._emit("    while running:")
        self._emit("        # Game variables")
        self._emit("        player = Player()")
        self._emit("        obstacles = []")
        self._emit("        road = Road()")
        self._emit("        game_active = True")
        self._emit("        spawn_timer = 0")
        self._emit(f"        difficulty = {difficulty}")
        self._emit("        ")
        self._emit("        # Game loop")
        self._emit("        while game_active:")
        self._emit("            clock.tick(FPS)")
        self._emit("            ")
        self._emit("            # Event handling")
        self._emit("            for event in pygame.event.get():")
        self._emit("                if event.type == pygame.QUIT:")
        self._emit("                    pygame.quit()")
        self._emit("                    sys.exit()")
        self._emit("                if event.type == pygame.KEYDOWN:")
        self._emit("                    if event.key == pygame.K_ESCAPE:")
        self._emit("                        pygame.quit()")
        self._emit("                        sys.exit()")
        self._emit("            ")
        self._emit("            # Get keys")
        self._emit("            keys = pygame.key.get_pressed()")
        self._emit("            player.move(keys)")
        self._emit("            ")
        self._emit("            # Spawn obstacles")
        self._emit("            spawn_timer += 1")
        self._emit("            if spawn_timer > difficulty:")
        self._emit("                obstacles.append(ObstacleCar())")
        self._emit("                spawn_timer = 0")
        self._emit("                # Increase difficulty over time")
        self._emit("                if difficulty > 30:")
        self._emit("                    difficulty -= 0.5")
        self._emit("            ")
        self._emit("            # Update obstacles")
        self._emit("            for obstacle in obstacles[:]:")
        self._emit("                obstacle.move()")
        self._emit("                if obstacle.is_off_screen():")
        self._emit("                    obstacles.remove(obstacle)")
        self._emit("                    player.score += 10")
        self._emit("                elif check_collision(player, obstacle):")
        self._emit("                    game_active = False")
        self._emit("            ")
        self._emit("            # Update road")
        self._emit("            road.update()")
        self._emit("            ")
        self._emit("            # Draw everything")
        self._emit("            screen.fill(GREEN)")
        self._emit("            road.draw(screen)")
        self._emit("            player.draw(screen)")
        self._emit("            for obstacle in obstacles:")
        self._emit("                obstacle.draw(screen)")
        self._emit("            ")
        self._emit("            # Draw UI")
        
        for item in ui_items:
            text = item['text'].replace('{score}', '" + str(player.score) + "')
            position = item['position']
            
            if position == 'topleft':
                self._emit(f'            draw_text(screen, "{text}", 36, 80, 10)')
            elif position == 'topright':
                self._emit(f'            draw_text(screen, "{text}", 24, WIDTH - 100, 10)')
            else:
                self._emit(f'            draw_text(screen, "{text}", 36, WIDTH // 2, 10)')
        
        self._emit("            ")
        self._emit("            pygame.display.flip()")
        self._emit("        ")
        self._emit("        # Game over")
        self._emit("        running = game_over_screen(player.score)")
        self._emit("    ")
        self._emit("    pygame.quit()")
        self._emit()
        self._emit('if __name__ == "__main__":')
        self._emit("    main()")
