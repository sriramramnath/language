"""Code generator for transpiling AST to Python/pygame code."""

from typing import List, Optional

from levlang.core.ast_node import (
    ASTNode, ProgramNode, GameNode, SpriteNode, SceneNode,
    EventHandlerNode, MethodNode, ExpressionNode, StatementNode,
    LiteralNode, IdentifierNode, BinaryOpNode, UnaryOpNode,
    CallNode, MemberAccessNode, AssignmentNode, IfNode,
    WhileNode, ForNode, ReturnNode, ExpressionStatementNode,
    PythonBlockNode
)


class CodeGenerator:
    """Generates Python/pygame code from an AST."""
    
    def __init__(self, ast: ProgramNode):
        """Initialize the code generator.
        
        Args:
            ast: The program AST to generate code from
        """
        self.ast = ast
        self.output: List[str] = []
        self.indent_level = 0
        self.indent_string = "    "  # 4 spaces per PEP 8
        
        # Track game configuration
        self.game_config = None
        self.sprites = []
        self.scenes = []
    
    def generate(self) -> str:
        """Generate Python code from the AST.
        
        Returns:
            The generated Python code as a string
        """
        self.output = []
        self.indent_level = 0
        
        # Visit the program node
        self.visit_program(self.ast)
        
        return "\n".join(self.output)
    
    def emit(self, line: str = ""):
        """Emit a line of code with proper indentation.
        
        Args:
            line: The line of code to emit (without indentation)
        """
        if line:
            self.output.append(self.indent_string * self.indent_level + line)
        else:
            self.output.append("")
    
    def indent(self):
        """Increase indentation level."""
        self.indent_level += 1
    
    def dedent(self):
        """Decrease indentation level."""
        if self.indent_level > 0:
            self.indent_level -= 1
    
    def visit_program(self, node: ProgramNode):
        """Visit a program node and generate code."""
        # First pass: collect game config, sprites, and scenes
        for declaration in node.declarations:
            if isinstance(declaration, GameNode):
                self.game_config = declaration
            elif isinstance(declaration, SpriteNode):
                self.sprites.append(declaration)
            elif isinstance(declaration, SceneNode):
                self.scenes.append(declaration)
        
        # Generate imports and header
        self.emit_imports()
        self.emit()
        
        # Generate sprite classes
        for sprite in self.sprites:
            self.visit_sprite(sprite)
            self.emit()
        
        # Generate game initialization and main loop
        # Generate if we have game config, scenes, or sprites
        if self.game_config or self.scenes or self.sprites:
            self.emit_game_initialization()
            self.emit()
            self.emit_game_loop()
    
    def emit_imports(self):
        """Generate import statements and file header."""
        # File header comment
        self.emit("# Generated by LevLang Transpiler")
        self.emit("# This file was automatically generated from LevLang source code")
        self.emit()
        
        # Import statements
        self.emit("import pygame")
        self.emit("import sys")
    
    def visit_sprite(self, node: SpriteNode):
        """Visit a sprite node and generate class code.
        
        Generates a Python class inheriting from pygame.sprite.Sprite.
        """
        # Class definition
        self.emit(f"class {node.name}(pygame.sprite.Sprite):")
        self.indent()
        
        # __init__ method
        self.emit("def __init__(self):")
        self.indent()
        self.emit("super().__init__()")
        
        # Add blank line before properties if there are any
        if node.properties:
            self.emit()
        
        # Initialize properties
        for prop_name, prop_value in node.properties.items():
            value_code = self.visit(prop_value)
            self.emit(f"self.{prop_name} = {value_code}")
        
        # If image property exists, set up rect
        if "image" in node.properties:
            self.emit()
            self.emit("# Load image and set up rect")
            self.emit("self.image = pygame.image.load(self.image)")
            self.emit("self.rect = self.image.get_rect()")
            
            # If x and y are defined, set position
            if "x" in node.properties and "y" in node.properties:
                self.emit("self.rect.center = (self.x, self.y)")
        
        self.dedent()
        
        # Generate event handler methods
        for method in node.methods:
            if isinstance(method, EventHandlerNode):
                self.emit()
                self.visit_event_handler_method(method)
        
        self.dedent()
    
    def visit_event_handler_method(self, node: EventHandlerNode):
        """Generate a method for an event handler within a sprite.
        
        Args:
            node: The event handler node
        """
        # Create method name from event type
        method_name = f"handle_{node.event_type}"
        
        # Method signature with parameters
        params = ", ".join(node.parameters)
        if params:
            self.emit(f"def {method_name}(self, {params}):")
        else:
            self.emit(f"def {method_name}(self):")
        
        self.indent()
        
        # Generate method body
        if node.body:
            for stmt in node.body:
                self.visit_statement(stmt)
        else:
            self.emit("pass")
        
        self.dedent()
    
    def visit_statement(self, node: StatementNode):
        """Visit a statement node and emit code.
        
        Args:
            node: The statement node to visit
        """
        if isinstance(node, AssignmentNode):
            self.visit_assignment_statement(node)
        elif isinstance(node, IfNode):
            self.visit_if_statement(node)
        elif isinstance(node, WhileNode):
            self.visit_while_statement(node)
        elif isinstance(node, ForNode):
            self.visit_for_statement(node)
        elif isinstance(node, ReturnNode):
            self.visit_return_statement(node)
        elif isinstance(node, ExpressionStatementNode):
            self.visit_expression_statement_emit(node)
        else:
            # Generic fallback
            pass
    
    def visit_assignment_statement(self, node: AssignmentNode):
        """Visit an assignment statement and emit code."""
        value_code = self.visit(node.value)
        # Check if target needs self. prefix (for sprite properties)
        self.emit(f"self.{node.target} = {value_code}")
    
    def visit_if_statement(self, node: IfNode):
        """Visit an if statement and emit code."""
        condition_code = self.visit(node.condition)
        self.emit(f"if {condition_code}:")
        self.indent()
        
        if node.then_block:
            for stmt in node.then_block:
                self.visit_statement(stmt)
        else:
            self.emit("pass")
        
        self.dedent()
        
        if node.else_block:
            self.emit("else:")
            self.indent()
            for stmt in node.else_block:
                self.visit_statement(stmt)
            self.dedent()
    
    def visit_while_statement(self, node: WhileNode):
        """Visit a while statement and emit code."""
        condition_code = self.visit(node.condition)
        self.emit(f"while {condition_code}:")
        self.indent()
        
        if node.body:
            for stmt in node.body:
                self.visit_statement(stmt)
        else:
            self.emit("pass")
        
        self.dedent()
    
    def visit_for_statement(self, node: ForNode):
        """Visit a for statement and emit code."""
        iterable_code = self.visit(node.iterable)
        self.emit(f"for {node.variable} in {iterable_code}:")
        self.indent()
        
        if node.body:
            for stmt in node.body:
                self.visit_statement(stmt)
        else:
            self.emit("pass")
        
        self.dedent()
    
    def visit_return_statement(self, node: ReturnNode):
        """Visit a return statement and emit code."""
        if node.value:
            value_code = self.visit(node.value)
            self.emit(f"return {value_code}")
        else:
            self.emit("return")
    
    def visit_expression_statement_emit(self, node: ExpressionStatementNode):
        """Visit an expression statement and emit code."""
        if node.expression:
            expr_code = self.visit(node.expression)
            self.emit(expr_code)
    
    def emit_game_initialization(self):
        """Generate game initialization code.
        
        Creates the main() function with pygame initialization and display setup.
        """
        self.emit("def main():")
        self.indent()
        
        # Initialize pygame
        self.emit("# Initialize pygame")
        self.emit("pygame.init()")
        self.emit()
        
        # Set up display
        if self.game_config:
            # Extract game properties
            width = 800  # Default
            height = 600  # Default
            title = "Game"  # Default
            
            if "width" in self.game_config.properties:
                width_node = self.game_config.properties["width"]
                width_code = self.visit(width_node)
                width = width_code
            
            if "height" in self.game_config.properties:
                height_node = self.game_config.properties["height"]
                height_code = self.visit(height_node)
                height = height_code
            
            if "title" in self.game_config.properties:
                title_node = self.game_config.properties["title"]
                title_code = self.visit(title_node)
                title = title_code
            
            self.emit("# Set up display")
            self.emit(f"screen = pygame.display.set_mode(({width}, {height}))")
            self.emit(f"pygame.display.set_caption({title})")
        else:
            self.emit("# Set up display")
            self.emit("screen = pygame.display.set_mode((800, 600))")
            self.emit("pygame.display.set_caption('Game')")
        
        self.emit()
        
        # Initialize clock for frame rate control
        self.emit("# Initialize clock for frame rate control")
        self.emit("clock = pygame.time.Clock()")
        self.emit()
    
    def emit_game_loop(self):
        """Generate the main game loop.
        
        Creates the game loop with event handling, update, and draw sections.
        """
        # Create sprite instances if any
        if self.sprites:
            self.emit("# Create sprite instances")
            for sprite in self.sprites:
                sprite_var = sprite.name.lower()
                self.emit(f"{sprite_var} = {sprite.name}()")
            self.emit()
        
        # Main game loop
        self.emit("# Main game loop")
        self.emit("running = True")
        self.emit("while running:")
        self.indent()
        
        # Event handling
        self.emit("# Event handling")
        self.emit("for event in pygame.event.get():")
        self.indent()
        self.emit("if event.type == pygame.QUIT:")
        self.indent()
        self.emit("running = False")
        self.dedent()
        
        # Generate event handler calls for sprites
        self.emit_event_handler_calls()
        
        self.dedent()
        self.emit()
        
        # Update section
        if self.scenes:
            scene = self.scenes[0]  # Use first scene
            if scene.update_block:
                self.emit("# Update")
                for stmt in scene.update_block:
                    self.visit_statement(stmt)
                self.emit()
        
        # Draw section
        if self.scenes:
            scene = self.scenes[0]  # Use first scene
            if scene.draw_block:
                self.emit("# Draw")
                for stmt in scene.draw_block:
                    self.visit_statement(stmt)
                self.emit()
        
        # Update display and tick clock
        self.emit("# Update display")
        self.emit("pygame.display.flip()")
        self.emit("clock.tick(60)")
        
        self.dedent()
        self.emit()
        
        # Quit pygame
        self.emit("# Quit pygame")
        self.emit("pygame.quit()")
        
        self.dedent()
        self.emit()
        
        # Entry point
        self.emit()
        self.emit("if __name__ == '__main__':")
        self.indent()
        self.emit("main()")
        self.dedent()
    
    def emit_event_handler_calls(self):
        """Generate calls to sprite event handlers based on pygame events.
        
        Maps game language event types to pygame event constants and generates
        conditional blocks to call sprite event handler methods.
        """
        # Map event types to pygame constants
        event_map = {
            'keydown': 'pygame.KEYDOWN',
            'keyup': 'pygame.KEYUP',
            'mousedown': 'pygame.MOUSEBUTTONDOWN',
            'mouseup': 'pygame.MOUSEBUTTONUP',
            'mousemove': 'pygame.MOUSEMOTION',
        }
        
        # Collect all event handlers from sprites
        for sprite in self.sprites:
            sprite_var = sprite.name.lower()
            
            for method in sprite.methods:
                if isinstance(method, EventHandlerNode):
                    event_type = method.event_type
                    
                    if event_type in event_map:
                        pygame_event = event_map[event_type]
                        
                        # Generate conditional for this event type
                        self.emit(f"if event.type == {pygame_event}:")
                        self.indent()
                        
                        # Generate parameter extraction and method call
                        if event_type == 'keydown' or event_type == 'keyup':
                            # Extract key name
                            self.emit("key = pygame.key.name(event.key).upper()")
                            self.emit(f"{sprite_var}.handle_{event_type}(key)")
                        elif event_type == 'mousedown' or event_type == 'mouseup':
                            # Extract button
                            self.emit("button = event.button")
                            self.emit(f"{sprite_var}.handle_{event_type}(button)")
                        elif event_type == 'mousemove':
                            # Extract position
                            self.emit("x, y = event.pos")
                            self.emit(f"{sprite_var}.handle_{event_type}(x, y)")
                        
                        self.dedent()
    
    def visit(self, node: ASTNode) -> str:
        """Generic visit method that dispatches to specific visit methods.
        
        Args:
            node: The AST node to visit
            
        Returns:
            Generated code for the node
        """
        if node is None:
            return ""
        
        # Map node types to visit methods
        visit_methods = {
            "program": lambda n: self.visit_program(n) or "",
            "sprite": lambda n: self.visit_sprite(n) or "",
            "expression": lambda n: self.visit_expression(n),
            "literal": lambda n: self.visit_literal(n),
            "identifier": lambda n: self.visit_identifier(n),
            "binary_op": lambda n: self.visit_binary_op(n),
            "unary_op": lambda n: self.visit_unary_op(n),
            "call": lambda n: self.visit_call(n),
            "member_access": lambda n: self.visit_member_access(n),
            "assignment": lambda n: self.visit_assignment(n),
            "if": lambda n: self.visit_if(n),
            "while": lambda n: self.visit_while(n),
            "for": lambda n: self.visit_for(n),
            "return": lambda n: self.visit_return(n),
            "expression_statement": lambda n: self.visit_expression_statement(n),
            "python_block": lambda n: self.visit_python_block(n),
        }
        
        # Get the visit method for this node type
        visit_method = visit_methods.get(node.node_type)
        if visit_method:
            return visit_method(node)
        else:
            return ""
    
    def visit_expression(self, node: ExpressionNode) -> str:
        """Visit an expression node."""
        return self.visit(node)
    
    def visit_literal(self, node: LiteralNode) -> str:
        """Visit a literal node and generate code.
        
        Args:
            node: The literal node
            
        Returns:
            Python code representing the literal
        """
        value = node.value
        
        # Handle different literal types
        if isinstance(value, bool):
            return "True" if value else "False"
        elif isinstance(value, str):
            # Return string with quotes (assuming value already has quotes from lexer)
            if value.startswith('"') or value.startswith("'"):
                return value
            else:
                return f'"{value}"'
        elif isinstance(value, (int, float)):
            return str(value)
        elif value is None:
            return "None"
        else:
            return str(value)
    
    def visit_identifier(self, node: IdentifierNode) -> str:
        """Visit an identifier node and generate code.
        
        Args:
            node: The identifier node
            
        Returns:
            Python code representing the identifier
        """
        return node.name
    
    def visit_binary_op(self, node: BinaryOpNode) -> str:
        """Visit a binary operation node and generate code.
        
        Args:
            node: The binary operation node
            
        Returns:
            Python code representing the binary operation
        """
        left_code = self.visit(node.left)
        right_code = self.visit(node.right)
        
        # Map operators to Python equivalents
        operator_map = {
            '&&': 'and',
            '||': 'or',
            '==': '==',
            '!=': '!=',
            '<': '<',
            '<=': '<=',
            '>': '>',
            '>=': '>=',
            '+': '+',
            '-': '-',
            '*': '*',
            '/': '/',
            '%': '%',
        }
        
        op = operator_map.get(node.operator, node.operator)
        return f"({left_code} {op} {right_code})"
    
    def visit_unary_op(self, node: UnaryOpNode) -> str:
        """Visit a unary operation node and generate code.
        
        Args:
            node: The unary operation node
            
        Returns:
            Python code representing the unary operation
        """
        operand_code = self.visit(node.operand)
        
        # Map operators to Python equivalents
        operator_map = {
            'not': 'not',
            '!': 'not',
            '-': '-',
        }
        
        op = operator_map.get(node.operator, node.operator)
        return f"({op} {operand_code})"
    
    def visit_call(self, node: CallNode) -> str:
        """Visit a function call node and generate code.
        
        Args:
            node: The call node
            
        Returns:
            Python code representing the function call
        """
        callee_code = self.visit(node.callee)
        
        # Generate argument list
        args = [self.visit(arg) for arg in node.arguments]
        args_str = ", ".join(args)
        
        return f"{callee_code}({args_str})"
    
    def visit_member_access(self, node: MemberAccessNode) -> str:
        """Visit a member access node and generate code.
        
        Args:
            node: The member access node
            
        Returns:
            Python code representing the member access
        """
        object_code = self.visit(node.object)
        return f"{object_code}.{node.member}"
    
    def visit_assignment(self, node: AssignmentNode) -> str:
        """Visit an assignment node and generate code.
        
        Args:
            node: The assignment node
            
        Returns:
            Python code representing the assignment
        """
        value_code = self.visit(node.value)
        return f"{node.target} = {value_code}"
    
    def visit_if(self, node: IfNode) -> str:
        """Visit an if statement node and generate code.
        
        Args:
            node: The if node
            
        Returns:
            Empty string (code is emitted directly)
        """
        # This is handled by visit_if_statement
        return ""
    
    def visit_while(self, node: WhileNode) -> str:
        """Visit a while loop node and generate code.
        
        Args:
            node: The while node
            
        Returns:
            Empty string (code is emitted directly)
        """
        # This is handled by visit_while_statement
        return ""
    
    def visit_for(self, node: ForNode) -> str:
        """Visit a for loop node and generate code.
        
        Args:
            node: The for node
            
        Returns:
            Empty string (code is emitted directly)
        """
        # This is handled by visit_for_statement
        return ""
    
    def visit_return(self, node: ReturnNode) -> str:
        """Visit a return statement node and generate code.
        
        Args:
            node: The return node
            
        Returns:
            Empty string (code is emitted directly)
        """
        # This is handled by visit_return_statement
        return ""
    
    def visit_expression_statement(self, node: ExpressionStatementNode) -> str:
        """Visit an expression statement node and generate code.
        
        Args:
            node: The expression statement node
            
        Returns:
            Python code representing the expression
        """
        if node.expression:
            return self.visit(node.expression)
        return ""
    
    def visit_python_block(self, node: PythonBlockNode) -> str:
        """Visit a Python block node and generate code.
        
        Python blocks are passed through as-is without modification,
        maintaining proper indentation in context.
        
        Args:
            node: The Python block node
            
        Returns:
            The raw Python code
        """
        # Split code into lines and emit each with current indentation
        if node.code:
            lines = node.code.split('\n')
            for line in lines:
                # Emit line with current indentation
                # The line might already have its own indentation which we preserve
                if line.strip():  # Only emit non-empty lines
                    self.emit(line)
                else:
                    self.emit()
        
        return ""
